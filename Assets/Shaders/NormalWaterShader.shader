Shader "Custom/NormalWaterShader"
{
    Properties
    {

		_DropTex ("Drop Texture (autogenerated, do not set)", 2D) = "black" {} //raindrop texture, set from drop compute shader

		_BaseColor("Water Base Color", Color) = (0,0,120,255)
		_FoamColor("Water Foam Color", Color) = (1,1,1,1)
		_IntersectColor("Intersection Color", Color) = (1,1,1,1)


		_NLMultiplier("N * L Multiplier", float) = 1
		_Ambient ("Ambient", Range (0, 1)) = 0.25
		_DiffuseColor ("Diffuse Color", Color) = (1,1,1,1)

		_SpeColor ("Specular Color", Color) = (1,1,1,1) 
        _SpecExp ("Specular Exponent", Float) = 10

		_IntersectIntensity("Intersection Intensity", float) = 10.0
		_IntersectExponent("Intersection Falloff Exponent", float) = 6.0

		_WaveA("Wave 1 (Direction, Steepness, Wavelength)", Vector) = (1,0,0.6,10)
		_WaveB("Wave 2 (Direction, Steepness, Wavelength)", Vector) = (0,1,0.3,8)
		_WaveC("Wave 3 (Direction, Steepness, Wavelength)", Vector) = (1,1,0.4,10)
    }
    SubShader
    {
        
        LOD 100
		Cull Off

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
			#include "UnityLightingCommon.cginc"



            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
				float2 dropuv : TEXCOORD5;
                float4 vertex : SV_POSITION;
				float3 normal : NORMAL;
				float4 screenPos : TEXCOORD1;
				float depth : TEXCOORD2; 
				float3 worldNormal : TEXCOORD3;
				float4 vertexWorld : TEXCOORD4;
            };



			sampler2D _DropTex;
			float4 _DropTex_ST;

			sampler2D _NoiseTex; //Noise Texture from noise compute
			float4 _NoiseTex_ST;

			float _Ambient;
			float4 _DiffuseColor;
			float _SpecExp;
			float4 _SpeColor;

			sampler2D _CameraDepthNormalsTexture;
			float _IntersectIntensity;
			float _IntersectExponent;
			float _NLMultiplier;


			float4 _BaseColor;
			float4 _FoamColor;
			float4 _IntersectColor;

			float4 _WaveA;
			float4 _WaveB;
			float4 _WaveC;



			float3 GerstnerWave (float4 wave, float3 p, inout float3 tangent, inout float3 binormal) {
				float steepness = wave.z;
				float wavelength = wave.w;
				float k = 2 * UNITY_PI / wavelength;
				float c = sqrt(9.8 / k);
				float2 d = normalize(wave.xy);
				float f = k * (dot(d, p.xz) - c * _Time.y);
				float a = steepness / k;

				tangent += float3(-d.x * d.x * (steepness * sin(f)), d.x * (steepness * cos(f)),-d.x * d.y * (steepness * sin(f)));
				binormal += float3(-d.x * d.y * (steepness * sin(f)), d.y * (steepness * cos(f)), -d.y * d.y * (steepness * sin(f)));
				return float3(d.x * (a * cos(f)), a * sin(f), d.y * (a * cos(f)));
			}


            v2f vert (appdata v)
            {
                v2f o;

				float3 gridpoint = v.vertex.xyz;
				float3 tangent = float3(1, 0, 0);
				float3 binormal = float3(0 ,0, 1);
				float3 p = mul(unity_ObjectToWorld,gridpoint);

				p += GerstnerWave(_WaveA, gridpoint, tangent, binormal);
				p += GerstnerWave(_WaveB, gridpoint, tangent, binormal);
				p += GerstnerWave(_WaveC, gridpoint, tangent, binormal);

				p = mul(unity_WorldToObject, p);

				float3 normal = normalize(cross(binormal, tangent));

                o.vertex = UnityObjectToClipPos(p);
                o.uv = TRANSFORM_TEX(v.uv, _NoiseTex);
				o.dropuv = TRANSFORM_TEX(v.uv, _DropTex);
				o.normal = normal;
				o.screenPos = ComputeScreenPos(o.vertex);
				o.depth = -mul(UNITY_MATRIX_MV, v.vertex).z * _ProjectionParams.w;

				o.worldNormal = UnityObjectToWorldNormal(normal);
				o.vertexWorld = mul(unity_ObjectToWorld, v.vertex);
                
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // difference to low poly: calculates color for all vertices and uses the Noise Texture AND the drop texture

                float4 col = 3 * _FoamColor * tex2D(_NoiseTex, i.uv) + _BaseColor;
                col = col.x > 0.5 ? float4(1,1,1,1) : col;
				float diff = DecodeFloatRG(tex2D(_CameraDepthNormalsTexture, i.screenPos.xy / i.screenPos.w).zw) - i.depth;
				float intersectGradient = 1 - min(diff / _ProjectionParams.w, 1.0f);
				fixed4 intersectTerm = _IntersectColor * pow(intersectGradient, _IntersectExponent) * _IntersectIntensity;

				//standard nl

            	float3 normalDirection = normalize(i.worldNormal);
            	float3 viewDirection = normalize(UnityWorldSpaceViewDir(i.vertexWorld));
				float3 lightDirection = normalize(UnityWorldSpaceLightDir(i.vertexWorld));

				float nl = max(_Ambient, dot(normalDirection, _WorldSpaceLightPos0.xyz) * _NLMultiplier);
				float4 diffuseTerm = nl * _DiffuseColor * col * _LightColor0;

				float3 reflectionDirection = -lightDirection - 2.0f * normalDirection * dot(normalDirection, -lightDirection);

				float3 specularDot = max(0.0, dot(viewDirection, reflectionDirection));
				float3 specular = pow(specularDot, _SpecExp);
				float4 specularTerm = float4(specular, 1) * _SpecColor * _LightColor0; 

				
                return fixed4(diffuseTerm.xyz + specularTerm.xyz + intersectTerm.xyz + tex2D(_DropTex, i.dropuv).xyz * 0.8,col.a); //add drop tex 

            }
            ENDHLSL
        }
    }
}
