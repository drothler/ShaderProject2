Shader "Custom/WaterWithTrail"
{
	//Trail shader in fragment function, otherwise normal water shader
    Properties
    {

		_DropTex ("Drop Texture (autogenerated, do not set)", 2D) = "black" {} 

		_BaseColor("Water Base Color", Color) = (0,0,120,255)
		_FoamColor("Water Foam Color", Color) = (1,1,1,1)
		_IntersectColor("Intersection Color", Color) = (1,1,1,1)


		_NLMultiplier("N * L Multiplier", float) = 1
		_Ambient ("Ambient", Range (0, 1)) = 0.25
		_DiffuseColor ("Diffuse Color", Color) = (1,1,1,1)

		_SpeColor ("Specular Color", Color) = (1,1,1,1) 
        _SpecExp ("Specular Exponent", Float) = 10

		_IntersectIntensity("Intersection Intensity", float) = 10.0
		_IntersectExponent("Intersection Falloff Exponent", float) = 6.0

		_WaveA("Wave 1 (Direction, Steepness, Wavelength)", Vector) = (1,0,0.6,10)
		_WaveB("Wave 2 (Direction, Steepness, Wavelength)", Vector) = (0,1,0.3,8)
		_WaveC("Wave 3 (Direction, Steepness, Wavelength)", Vector) = (1,1,0.4,10)

		//Trail Properties
		_BoatPosition("Boat Position (x, z, yRot, speed)", Vector) = (0,0,0,0)
		_TrailTexture("Trail Texture", 2D) = "white" {}
		_FrontTexture("Front Texture", 2D) = "white" {}
		_TrailColor("TrailColor", COLOR) = (0,0,0,0)
		_TrailSize("TrailSize", float) = 4
		_TrailSpeed("TrailSpeed", float) = 1
		_TextureOffset("TextureOffset", float) = 0.68
    }
    SubShader
    {
        
        LOD 100

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
			#include "UnityLightingCommon.cginc"



            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
				float2 dropuv : TEXCOORD5;
                float4 vertex : SV_POSITION;
				float3 normal : NORMAL;
				float4 screenPos : TEXCOORD1;
				float depth : TEXCOORD2; 
				float3 worldNormal : TEXCOORD3;
				float4 vertexWorld : TEXCOORD4;
				float3 worldPos : TEXCOORD6;
            };



			sampler2D _DropTex;
			float4 _DropTex_ST;

			sampler2D _NoiseTex; //Noise Texture from noise compute
			float4 _NoiseTex_ST;

			float _Ambient;
			float4 _DiffuseColor;
			float _SpecExp;
			float4 _SpeColor;

			sampler2D _CameraDepthNormalsTexture;
			float _IntersectIntensity;
			float _IntersectExponent;
			float _NLMultiplier;


			float4 _BaseColor;
			float4 _FoamColor;
			float4 _IntersectColor;

			float _Steepness;
			float _Wavelength;
			float2 _Direction;

			float4 _WaveA;
			float4 _WaveB;
			float4 _WaveC;

			float4 _TrailColor;
			float4 _BoatPosition;
			sampler2D _TrailTexture;
			sampler2D _FrontTexture;
			float _TrailSize;
			float _TrailSpeed;
			float _TextureOffset;


			//Barycentric check
			bool insideTriangle(float2 p, float2 a, float2 b, float2 c) {
			
				float alpha1 = (a.x*(c.y-a.y) + (p.y-a.y)*(c.x-a.x) - p.x*(c.y-a.y))/ ((b.y-a.y)*(c.x-a.x) - (b.x-a.x)*(c.y-a.y));
				float alpha2 = (p.y-a.y-alpha1*(b.y-a.y))/(c.y-a.y);

				return (alpha1 >=0.0 && alpha2 >=0.0 && (alpha1 + alpha2) <= 1);
			}


			float3 GerstnerWave (float4 wave, float3 p, inout float3 tangent, inout float3 binormal) {
				float steepness = wave.z;
				float wavelength = wave.w;
				float k = 2 * UNITY_PI / wavelength;
				float c = sqrt(9.8 / k);
				float2 d = normalize(wave.xy);
				float f = k * (dot(d, p.xz) - c * _Time.y);
				float a = steepness / k;

				tangent += float3(-d.x * d.x * (steepness * sin(f)), d.x * (steepness * cos(f)),-d.x * d.y * (steepness * sin(f)));
				binormal += float3(-d.x * d.y * (steepness * sin(f)), d.y * (steepness * cos(f)), -d.y * d.y * (steepness * sin(f)));
				return float3(d.x * (a * cos(f)), a * sin(f), d.y * (a * cos(f)));
			}


            v2f vert (appdata v)
            {
                v2f o;

				float3 gridpoint = v.vertex.xyz;
				float3 tangent = float3(1, 0, 0);
				float3 binormal = float3(0 ,0, 1);
				float3 p = mul(unity_ObjectToWorld,gridpoint);

				p += GerstnerWave(_WaveA, gridpoint, tangent, binormal);
				p += GerstnerWave(_WaveB, gridpoint, tangent, binormal);
				p += GerstnerWave(_WaveC, gridpoint, tangent, binormal);

				p = mul(unity_WorldToObject, p);

				float3 normal = normalize(cross(binormal, tangent));

                o.vertex = UnityObjectToClipPos(p);
                o.uv = TRANSFORM_TEX(v.uv, _NoiseTex);
				o.dropuv = TRANSFORM_TEX(v.uv, _DropTex);
				o.normal = normal;
				o.screenPos = ComputeScreenPos(o.vertex);
				o.depth = -mul(UNITY_MATRIX_MV, v.vertex).z * _ProjectionParams.w;

				o.worldNormal = UnityObjectToWorldNormal(normal);
				o.vertexWorld = mul(unity_ObjectToWorld, v.vertex);
				o.worldPos = mul(unity_ObjectToWorld, v.vertex);
                
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // difference to low poly: calculates color for all vertices and uses the Noise Texture AND the drop texture

                float4 col = 2 * _FoamColor * tex2D(_NoiseTex, i.uv) + _BaseColor;
                col = col.x > 0.5 ? float4(1,1,1,1) : col;
				float diff = DecodeFloatRG(tex2D(_CameraDepthNormalsTexture, i.screenPos.xy / i.screenPos.w).zw) - i.depth;
				float intersectGradient = 1 - min(diff / _ProjectionParams.w, 1.0f);
				fixed4 intersectTerm = _IntersectColor * pow(intersectGradient, _IntersectExponent) * _IntersectIntensity;

				//standard nl

            	float3 normalDirection = normalize(i.worldNormal);
            	float3 viewDirection = normalize(UnityWorldSpaceViewDir(i.vertexWorld));
				float3 lightDirection = normalize(UnityWorldSpaceLightDir(i.vertexWorld));

				float nl = max(_Ambient, dot(normalDirection, _WorldSpaceLightPos0.xyz) * _NLMultiplier);
				float4 diffuseTerm = nl * _DiffuseColor * col * _LightColor0;

				float3 reflectionDirection = -lightDirection - 2.0f * normalDirection * dot(normalDirection, -lightDirection);

				float3 specularDot = max(0.0, dot(viewDirection, reflectionDirection));
				float3 specular = pow(specularDot, _SpecExp);
				float4 specularTerm = float4(specular, 1) * _SpecColor * _LightColor0; 


				//Trail Term this part is different from normal water shader
				float2 offsetVector = i.worldPos.xz-_BoatPosition.xy;
				//correct rounding errors
				_BoatPosition.z = radians(round(_BoatPosition.z)+0.1);
				
				float2x2 rotationMatrix = float2x2(cos(_BoatPosition.z), -sin(_BoatPosition.z), sin(_BoatPosition.z), cos(_BoatPosition.z));
				float2x2 inverseRot = (1/determinant(rotationMatrix)) *float2x2(cos(_BoatPosition.z), sin(_BoatPosition.z), -sin(_BoatPosition.z), cos(_BoatPosition.z));
				float2 middle = float2(0.5, 0.5);

				//UV bounds in world coordinates
				float2 lowerLeftBounds = mul(inverseRot, float2(-_TrailSize, -_TrailSize));
				float2 upperRightBounds = mul(inverseRot, float2(_TrailSize, _TrailSize));
				float2 upperLeftBounds = mul(inverseRot, float2(-_TrailSize, _TrailSize));
				float2 lowerRightBounds = mul(inverseRot, float2(_TrailSize, -_TrailSize));
				float2 samplePos = middle + (mul(rotationMatrix, offsetVector))/_TrailSize;
				float4 colorTex = float4(0,0,0,0);

				//Rotateble square with texture inside, texture at boat position on water
				if(insideTriangle(offsetVector, upperLeftBounds, lowerRightBounds, upperRightBounds)
					|| insideTriangle(offsetVector, upperLeftBounds, lowerRightBounds, lowerLeftBounds)) {
					
					//Different textures, static upper part. Scrolling lower part
					if(samplePos.y > _TextureOffset) {
						colorTex = tex2D(_FrontTexture, samplePos);
					} else {
						colorTex = tex2D(_TrailTexture, samplePos + float2(0, _Time.y * _TrailSpeed));
						colorTex += tex2D(_FrontTexture, samplePos);
					}

					
				}
			
                return fixed4(diffuseTerm.xyz + specularTerm.xyz + intersectTerm.xyz + tex2D(_DropTex, i.dropuv).xyz * 0.8 + colorTex.xyz, col.a);
            }
            ENDHLSL
        }
    }
}
